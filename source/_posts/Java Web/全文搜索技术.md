---
layout: post
title: 全文搜索技术:Lucene和Solr
comments: true
toc: true
date: 2017-06-20 15:25:36
tags:
	- Java
	- 全文搜索技术
	- Lucene
	- Solr
---

Lucene和Solr都是基于Java的高效全文检索库.

<img src="http://img1.imgtn.bdimg.com/it/u=1353965261,3049014125&fm=214&gp=0.jpg" alt="hello" style="width: 50%; text-align: center; display: block; margin-top:30px; margin-bottom:30px"/>

<!--more-->

## <font color=orange> 数据分类 </font>

我们生活中的数据总体分为两种:<font color=orange>结构化数据</font>和<font color=orange>非结构化数据</font>。

* 结构化数据:指具有固定格式或有限长度的数据，如数据库，元数据等。
* 非结构化数据:指不定长或无固定格式的数据，如邮件，word文档等磁盘上的文件

## <font color=orange> 非结构化数据查询方法 </font>

* 顺序扫描法(Serial Scanning)
所谓顺序扫描，比如要找内容包含某一个字符串的文件，就是一个文档一个文档的看，对于每一个文档，从头看到尾，如果此文档包含此字符串，则此文档为我们要找的文件，接着看下一个文件，直到扫描完所有的文件。如利用windows的搜索也可以搜索文件内容，只是相当的慢。
* 全文检索(Full-text Search)
将非结构化数据中的一部分信息提取出来，重新组织，使其变得有一定结构，然后对此有一定结构的数据进行搜索，从而达到搜索相对较快的目的。这部分从非结构化数据中提取出的然后重新组织的信息，我们称之索引。
例如：字典。字典的拼音表和部首检字表就相当于字典的索引，对每一个字的解释是非结构化的，如果字典没有音节表和部首检字表，在茫茫辞海中找一个字只能顺序扫描。然而字的某些信息可以提取出来进行结构化处理，比如读音，就比较结构化，分声母和韵母，分别只有几种可以一一列举，于是将读音拿出来按一定的顺序排列，每一项读音都指向此字的详细解释的页数。我们搜索时按结构化的拼音搜到读音，然后按其指向的页数，便可找到我们的非结构化数据——也即对字的解释。
这种先建立索引，再对索引进行搜索的过程就叫全文检索(Full-text Search)。

## <font color=orange> 全文检索的一般步骤</font>

全文检索大体分两个过程，索引创建 (Indexing) 和搜索索引 (Search) 。

* 索引创建：将现实世界中所有的结构化和非结构化数据提取信息，创建索引的过程。
* 搜索索引：就是得到用户的查询请求，搜索创建的索引，然后返回结果的过程。

## <font color=orange> Lucene的使用 </font>
### <font color=orange> 创建索引库 </font>
将原始内容创建为包含域（Field）的文档（document），需要再对域中的内容进行分析，分析的过程是经过对原始文档提取单词、将字母转为小写、去除标点符号、去除停用词等过程生成最终的语汇单元，可以将语汇单元理解为一个一个的单词。
#### <font color=orange> Field域的属性 </font>
|Field类|数据类型|Analyzed是否分析|Indexed是否索引|Stored是否存储|说明|
|:---:|:---:|:---:|:---:|:---:|:---:|
|StringField(FieldName, FieldValue,Store.YES))|	字符串|	N|	Y	|Y或N	|这个Field用来构建一个字符串Field，但是不会进行分析，会将整个串存储在索引中，比如(订单号,姓名等)是否存储在文档中用Store.YES或Store.NO决定|
|LongField(FieldName, FieldValue,Store.YES)|	Long型 |	Y	|Y	|Y或N|这个Field用来构建一个Long数字型Field，进行分析和索引，比如(价格) 是否存储在文档中用Store.YES或Store.NO决定|
|StoredField(FieldName, FieldValue) |	重载方法，支持多种类型	|N|	N	|Y	|这个Field用来构建不同类型Field不分析，不索引，但要Field存储在文档中(如图片,因为要存放图片地址)|
|TextField(FieldName, FieldValue, Store.NO)或TextField(FieldName, reader)|字符串或流|Y|Y|Y或N|如果是一个Reader, lucene猜测内容比较多,会采用Unstored的策略.|

#### <font color=orange> 使用的jar包 </font>
* Lucene包
	* lucene-core-4.10.3.jar
	* lucene-analyzers-common-4.10.3.jar
	* lucene-queryparser-4.10.3.jar
* 其它
	* commons-io-2.4.jar
	* junit-4.9.jar

#### <font color=orange> 创建索引实例代码 </font>
```java
//创建索引
puclic class CreateIndex {
    @Test
    public void createIndex() throws Exception {
        //指定索引库存放的路径
        //  /Users/apple/indexData
        Directory directory = FSDirectory.open(new File("/Users/apple/indexData"));
        //索引库还可以存放到内存中
        //Directory directory = new RAMDirectory();
        //创建一个标准分析器
        Analyzer analyzer = new StandardAnalyzer();
        //创建indexwriterCofig对象
        //第一个参数： Lucene的版本信息，可以选择对应的lucene版本也可以使用LATEST
        //第二根参数：分析器对象
        IndexWriterConfig config = new IndexWriterConfig(Version.LATEST, analyzer);
        //创建indexwriter对象
        IndexWriter indexWriter = new IndexWriter(directory, config);
        //原始文档的路径: /Users/apple/data
        File dir = new File("/Users/apple/data");
        for (File f : dir.listFiles()) {
            //文件名
            String fileName = f.getName();
            //文件内容
            String fileContent = FileUtils.readFileToString(f);
            //文件路径
            String filePath = f.getPath();
            //文件的大小
            long fileSize  = FileUtils.sizeOf(f);
            //创建文件名域
            //第一个参数：域的名称
            //第二个参数：域的内容
            //第三个参数：是否存储
            Field fileNameField = new TextField("filename", fileName, Store.YES);
            //文件内容域
            Field fileContentField = new TextField("content", fileContent, Store.YES);
            //文件路径域（不分析、不索引、只存储）
            Field filePathField = new StoredField("path", filePath);
            //文件大小域
            Field fileSizeField = new LongField("size", fileSize, Store.YES);
			
            //创建document对象
            Document document = new Document();
            document.add(fileNameField);
            document.add(fileContentField);
            document.add(filePathField);
            document.add(fileSizeField);
            //创建索引，并写入索引库
            indexWriter.addDocument(document);
        }
        //关闭indexwriter
        indexWriter.close();
    }
}
```
### <font color=orange> 查询索引 </font>
查询索引也是搜索的过程。搜索就是用户输入关键字，从索引（index）中进行搜索的过程。根据关键字搜索索引，根据索引找到对应的文档，从而找到要搜索的内容（这里指磁盘上的文件）。
图形化界面可以使用Luke工具查看索引文件.

#### <font color=orange> IndexSearcher搜索方法 </font>
|方法|说明|
|:---:|:---:|
|indexSearcher.search(query, n)	|根据Query搜索，返回评分最高的n条记录|
|indexSearcher.search(query, filter, n)	|根据Query搜索，添加过滤策略，返回评分最高的n条记录|
|indexSearcher.search(query, n, sort)	|根据Query搜索，添加排序策略，返回评分最高的n条记录|
|indexSearcher.search(booleanQuery, filter, n, sort)	|根据Query搜索，添加过滤策略，添加排序策略，返回评分最高的n条记录|
#### <font color=orange> 查询索引实例代码 </font>
```java
public class QueryIndex {
    @Test
    public void searchIndex() throws Exception {
        //指定索引库存放的路径
        //   /Users/apple/indexData
        Directory directory = FSDirectory.open(new File("/Users/apple/indexData"));
        //创建indexReader对象
        IndexReader indexReader = DirectoryReader.open(directory);
        //创建indexsearcher对象
        IndexSearcher indexSearcher = new IndexSearcher(indexReader);
        //创建查询
        Query query = new TermQuery(new Term("filename", "apache"));
        //执行查询
        //第一个参数是查询对象，第二个参数是查询结果返回的最大值
        TopDocs topDocs = indexSearcher.search(query, 10);
        //查询结果的总条数
        System.out.println("查询结果的总条数："+ topDocs.totalHits);
        //遍历查询结果
        //topDocs.scoreDocs存储了document对象的id
        for (ScoreDoc scoreDoc : topDocs.scoreDocs) {
            //scoreDoc.doc属性就是document对象的id
            //根据document的id找到document对象
            Document document = indexSearcher.doc(scoreDoc.doc);
            System.out.println(document.get("filename"));
            //System.out.println(document.get("content"));
            System.out.println(document.get("path"));
            System.out.println(document.get("size"));
        }
        //关闭indexreader对象
        indexReader.close();
    }
}
```

### <font color=orange> 中文分析器 </font>
#### <font color=orange> Lucene自带中文分词器 </font>
* StandardAnalyzer
	* 单字分词：就是按照中文一个字一个字地进行分词。如：“我爱中国”，效果：“我”、“爱”、“中”、“国”。
* CJKAnalyzer
	* 二分法分词：按两个字进行切分。如：“我是中国人”，效果：“我是”、“是中”、“中国”“国人”。
* SmartChineseAnalyzer
	* 对中文支持较好，但扩展性差，扩展词库，禁用词库和同义词库等不好处理
	
#### <font color=orange> 第三方中文分析器 </font>
* paoding
	* 已经过时, 停止更新
* mmseg4j
	* [github地址](https://github.com/chenlb/mmseg4j-solr)
* IK-analyzer
	* [地址](https://code.google.com/p/ik-analyzer/)
	* 2012年之后停止更新
	
### <font color=orange> 索引库的维护 </font>
#### <font color=orange> 索引库的添加 </font>
```java
//添加索引
public class EditIndex {
    @Test
    public void addDocument() throws Exception {
        //索引库存放路径
        Directory directory = FSDirectory.open(new File("/Users/apple/indexData"));
		
        IndexWriterConfig config = new IndexWriterConfig(Version.LATEST, new IKAnalyzer());
        //创建一个indexwriter对象
        IndexWriter indexWriter = new IndexWriter(directory, config);
        //创建一个Document对象
        Document document = new Document();
        //向document对象中添加域。
        //不同的document可以有不同的域，同一个document可以有相同的域。
        document.add(new TextField("filename", "新添加的文档", Store.YES));
        document.add(new TextField("content", "新添加的文档的内容", Store.NO));
        document.add(new TextField("content", "新添加的文档的内容第二个content", Store.YES));
        document.add(new TextField("content1", "新添加的文档的内容要能看到", Store.YES));
        //添加文档到索引库
        indexWriter.addDocument(document);
        //关闭indexwriter
        indexWriter.close();	
    }
}
```
#### <font color=orange> 索引库删除 </font>
##### <font color=orange> 删除全部 </font>
```java
//删除全部索引
@Test
public void deleteAllIndex() throws Exception {
    IndexWriter indexWriter = getIndexWriter();
    //删除全部索引
    indexWriter.deleteAll();
    //关闭indexwriter
    indexWriter.close();
}
```
##### <font color=orange>指定查询条件删除</font>
```java
//根据查询条件删除索引
@Test
public void deleteIndexByQuery() throws Exception {
    IndexWriter indexWriter = getIndexWriter();
    //创建一个查询条件
    Query query = new TermQuery(new Term("filename", "apache"));
    //根据查询条件删除
    indexWriter.deleteDocuments(query);
    //关闭indexwriter
    indexWriter.close();
}
```
#### <font color=orange> 索引库的修改 </font>
原理就是先删除后添加。
```java
//修改索引库
@Test
public void updateIndex() throws Exception {
    IndexWriter indexWriter = getIndexWriter();
    //创建一个Document对象
    Document document = new Document();
    //向document对象中添加域。
    //不同的document可以有不同的域，同一个document可以有相同的域。
    document.add(new TextField("filename", "要更新的文档", Store.YES));
    document.add(new TextField("content", "2013年11月18日 - Lucene 简介 Lucene 是一个基于 Java 的全文信息检索工具包,它不是一个完整的搜索应用程序,而是为你的应用程序提供索引和搜索功能。", Store.YES));
    indexWriter.updateDocument(new Term("content", "java"), document);
    //关闭indexWriter
    indexWriter.close();
}
```
#### <font color=red> 索引库的查询</font>
对要搜索的信息创建Query查询对象，Lucene会根据Query查询对象生成最终的查询语法，类似关系数据库Sql语法一样Lucene也有自己的查询语法，比如：“name:lucene”表示查询Field的name为“lucene”的文档信息。
可通过两种方法创建查询对象：
* 1、使用Lucene提供Query子类
	* Query是一个抽象类，lucene提供了很多查询对象，比如TermQuery项精确查询，NumericRangeQuery数字范围查询等。
	* 如下代码：
		* Query query = new TermQuery(new Term("name", "lucene"));
* 2、使用QueryParse解析查询表达式
	* QueryParse会将用户输入的查询表达式解析成Query对象实例。
	* 如下代码：
		* QueryParser queryParser = new QueryParser("name", new IKAnalyzer());
		* Query query = queryParser.parse("name:lucene");

##### <font color=orange> 使用query的子类查询</font>
###### <font color=red>TermQuery</font>
TermQuery，通过项查询，TermQuery不使用分析器所以建议匹配不分词的Field域查询，比如订单号、分类ID号等。
```java
//使用Termquery查询
@Test
public void testTermQuery() throws Exception {
    IndexSearcher indexSearcher = getIndexSearcher();
    //创建查询对象
    Query query = new TermQuery(new Term("content", "lucene"));
    //执行查询
    TopDocs topDocs = indexSearcher.search(query, 10);
    //共查询到的document个数
    System.out.println("查询结果总数量：" + topDocs.totalHits);
    //遍历查询结果
    for (ScoreDoc scoreDoc : topDocs.scoreDocs) {
        Document document = indexSearcher.doc(scoreDoc.doc);
        System.out.println(document.get("filename"));
        //System.out.println(document.get("content"));
        System.out.println(document.get("path"));
        System.out.println(document.get("size"));
    }
    //关闭indexreader
    indexSearcher.getIndexReader().close();
}
```
###### <font color=red>NumericRangeQuery</font>
可以根据数值范围查询。
```java
//数值范围查询
@Test
public void testNumericRangeQuery() throws Exception {
    IndexSearcher indexSearcher = getIndexSearcher();
    //创建查询
    //参数：
    //1.域名
    //2.最小值
    //3.最大值
    //4.是否包含最小值
    //5.是否包含最大值
    Query query = NumericRangeQuery.newLongRange("size", 1l, 1000l, true, true);
    //执行查询
    printResult(query, indexSearcher);
}
```
###### <font color=red>BooleanQuery</font>
可以组合查询条件。
Occur.MUST：必须满足此条件，相当于and
Occur.SHOULD：应该满足，但是不满足也可以，相当于or
Occur.MUST_NOT：必须不满足。相当于not
```java
//组合条件查询
@Test
public void testBooleanQuery() throws Exception {
    IndexSearcher indexSearcher = getIndexSearcher();
    //创建一个布尔查询对象
    BooleanQuery query = new BooleanQuery();
    //创建第一个查询条件
    Query query1 = new TermQuery(new Term("filename", "apache"));
    Query query2 = new TermQuery(new Term("content", "apache"));
    //组合查询条件
    query.add(query1, Occur.MUST);
    query.add(query2, Occur.MUST);
    //执行查询
    printResult(query, indexSearcher);
}
```
###### <font color=red> MatchAllDocsQuery </font>
使用MatchAllDocsQuery查询索引目录中的所有文档
```java
@Test
public void testMatchAllDocsQuery() throws Exception {
    IndexSearcher indexSearcher = getIndexSearcher();
    //创建查询条件
    Query query = new MatchAllDocsQuery();
    //执行查询
    printResult(query, indexSearcher);
}
```
##### <font color=orange> 使用queryparser查询 </font>
###### <font color=red> QueryParser </font>
需要加入queryParser依赖的jar包(lucene-queryparser-4.10.3.jar)
```java
@Test
public void testQueryParser() throws Exception {
    IndexSearcher indexSearcher = getIndexSearcher();
    //创建queryparser对象
    //第一个参数默认搜索的域
    //第二个参数就是分析器对象
    QueryParser queryParser = new QueryParser("content", new IKAnalyzer());
    Query query = queryParser.parse("Lucene是java开发的");
    //执行查询
    printResult(query, indexSearcher);
}
```
* 查询语法
	* 基础的查询: `域名:关键字`
		* 如: `content:java`
	* 范围查询: `域名+“:”+[最小值 TO 最大值]`
		* 如: `size:[1 TO 1000]`
		* 范围查询在lucene中不支持数值类型，支持字符串类型。在solr中支持数值类型。
	* 组合条件查询
		* +条件1 +条件2: 两个条件之间是并且的关系and
			* 如: `+filename:apache +content:apache`
			* 另外一种写法: `条件1 AND 条件2`
		* +条件1 条件2: 必须满足第一个条件，应该满足第二个条件
			* 如: `+filename:apache content:apache`
		* 条件1 条件2：两个条件满足其一即可
			* 如: `filename:apache content:apache`
			* 另外一种写法: `条件1 OR 条件2`
		* -条件1 条件2：必须不满足条件1，要满足条件2
			* 如: `-filename:apache content:apache`
			* 另外一种写法: `条件1 NOT 条件2`
		
###### <font color=red> MulitFieldQueryParser </font>
可以指定多个默认搜索域
```java
@Test
public void testMultiFiledQueryParser() throws Exception {
    IndexSearcher indexSearcher = getIndexSearcher();
    //可以指定默认搜索的域是多个
    String[] fields = {"filename", "content"};
    //创建一个MulitFiledQueryParser对象
    MultiFieldQueryParser queryParser = new MultiFieldQueryParser(fields, new IKAnalyzer());
    Query query = queryParser.parse("java and apache");
    System.out.println(query);
    //执行查询
    printResult(query, indexSearcher);	
}
```
## <font color=orange> Solr的使用 </font>
单独使用Lucene实现站内搜索需要开发的工作量较大，主要表现在：索引维护、索引性能优化、搜索性能优化等，因此不建议采用。
基于Solr实现站内搜索扩展性较好并且可以减少程序员的工作量，因为Solr提供了较为完备的搜索引擎解决方案，因此在门户、论坛等系统中常用此方案。
### <font color=orange> 什么是Solr </font>
Solr 是Apache下的一个顶级开源项目，采用Java开发，它是基于Lucene的全文搜索服务器。Solr提供了比Lucene更为丰富的查询语言，同时实现了可配置、可扩展，并对索引、搜索性能进行了优化。 
Solr可以独立运行，运行在Jetty、Tomcat等这些Servlet容器中，Solr 索引的实现方法很简单，用 POST 方法向 Solr 服务器发送一个描述 Field 及其内容的 XML 文档，Solr根据xml文档添加、删除、更新索引 。Solr 搜索只需要发送 HTTP GET 请求，然后对 Solr 返回Xml、json等格式的查询结果进行解析，组织页面布局。Solr不提供构建UI的功能，Solr提供了一个管理界面，通过管理界面可以查询Solr的配置和运行情况。
### <font color=orange> Solr与Lucene的区别 </font>
* Lucene是一个开放源代码的全文检索引擎工具包，它不是一个完整的全文检索引擎，Lucene提供了完整的查询引擎和索引引擎，目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能，或者以Lucene为基础构建全文检索引擎。
* Solr的目标是打造一款企业级的搜索引擎系统，它是一个搜索引擎服务，可以独立运行，通过Solr可以非常快速的构建企业的搜索引擎，通过Solr也可以高效的完成站内搜索功能。

### <font color=orange> 安装Solr </font>
#### <font color=orange> Solr下载地址 </font>

* [官网下载地址](http://lucene.apache.org/solr/)
* [华中科技大学镜像站](http://mirrors.hust.edu.cn/apache/lucene/solr)
* [上海大学镜像站](http://mirrors.shu.edu.cn/apache/lucene/solr)
* [清华大学镜像站](http://mirrors.tuna.tsinghua.edu.cn/apache/lucene/solr)
* [北京理工大学镜像站](http://mirror.bit.edu.cn/apache/lucene/solr)

#### <font color=orange> Solr解压目录说明 </font>
* Solr4.10.3解压目录
	* bin: solr的运行脚本
	* contrib: solr的一些软件/插件，用于增强solr的功能。
	* dist: 该目录包含build过程中产生的war和jar文件，以及相关的依赖文件。
		* solr-x.x.x.war: 部署到tomcat时拷贝到`tomcat/webapps`后运行即可,停掉tomcat之后即可删除`tomcat/webapps/solr-x.x.x.war`
		* solr-solrj-x.x.x.jar: Java连接solr服务器使用
	* docs: solr的API文档
	* example: solr工程的例子目录：
		* example/lib/ext: 如果solr需要部署到tomcat, 需要把里面的jar拷贝到`tomcat/webapps/solr/WEB-INF/lib/`下
		* example/solr: 该目录是一个包含了默认配置信息的Solr-Home目录。
		* example/multicore: 该目录包含了在Solr的multicore中设置的多个Core目录。 
		* example/webapps: 该目录中包括一个solr.war，该war可作为solr的运行实例工程。
	* licenses: solr相关的一些许可信息
* Solr5.5.5解压目录
	* bin: solr的运行脚本
	* contrib: solr的一些软件/插件，用于增强solr的功能。
	* dist: 该目录包含build过程中产生的war和jar文件，以及相关的依赖文件。
	* docs: solr的API文档
	* licenses: solr相关的一些许可信息
	* server: solr服务
		* solr-webapp/webapp: 里面的可以拷贝到Tomcat的webapps中, 部署到tomcat
		* server/lib/ext: 里面的jar需要拷贝到tomcat/webapps/solr/WEB-INF/lib下面
	* example: solr工程的例子目录

#### <font color=orange> Solr运行环境 </font>
Solr需要运行在一个Servlet容器中，Solr4.10.3要求jdk使用1.7以上，Solr默认提供Jetty（java写的Servlet容器），本教程使用Tocmat作为Servlet容器，环境如下：
* Solr: Solr4.10.3
* JDK: JDK1.7.0_72
* Tomcat: apache-tomcat-7.0.53

#### <font color=orange> Solr和Tomcat整合</font>
##### <font color=orange> Solr Home与SolrCore </font>
创建一个Solr home目录，SolrHome是Solr运行的主目录，目录中包括了运行Solr实例所有的配置文件和数据文件，Solr实例就是SolrCore，一个SolrHome可以包括多个SolrCore（Solr实例），每个SolrCore提供单独的搜索和索引服务。
* `Solr-4.x.x/example/solr`就是一个Solr Home目录结构
* `Solr-4.x.x/example/solr/collection1`是一个Solr实例

##### <font color=orange> Solr-4.x.x部署Tomcat</font>
* 1、解压Solr-4.x.x.tar.gz
* 2、将solr解压目录中`solr-4.x.x/dist/solr-4.x.x.war`拷贝到tomcat安装目录下`/webapps`中, 并重命名为`solr.war`
* 3、运行Tomcat, 启动后停止Tomcat, 删除tomcat安装目录下的`/webapps/solr.war`
* 4、拷贝solr解压目录`solr-4.x.x/example/lib/ext`中的的jar包到tomcat安装目录`/webapps/solr/WEB-INF/lib/`中
* 5、配置Solr home
	* 5.1、拷贝solr解压目录`/solr-4.x.x/example/solr`拷贝到其他目录中, 可以重新命名, 如`/usr/local/solrhome`
	* 5.2、solrhome目录下面可能会有多个solr实例, 每个solr实例文件夹下面的`conf/solrconfig.xml`, 可以配置相关的solr配置.
* 6、修改tomcat安装目录下`/webapps/solr/WEB-INF/web.xml`
```xml
<env-entry>
    <env-entry-name>solr/home</env-entry-name>
    <env-entry-value>/usr/local/solrhome</env-entry-value>
    <env-entry-type>java.lang.String</env-entry-type>
</env-entry>
```

	* `env-entry-name`: 名字必须是`solr/home`, 不能更改
	* `env-entry-value`: 里面的值就是Solr Home路径
* 7、其他tomcat, 通过`tomcat地址:端口/solr`访问

##### <font color=orange> Solr-5.x.x部署Tomcat</font>

<font color=red>Solr-5.x.x最好使用Tomcat8</font>

* 1、解压Solr-5.x.x.tar.gz
* 2、将solr解压目录`Solr-5.x.x/server/solr-webapp/webapp`拷贝到tomcat安装目录`/webapps`中, 并改名solr
* 3、将solr解压目录`Solr-5.x.x/server/lib/ext`中jar包拷贝到tomcat安装目录`/webapps/solr/WEB-INF/lib`中
* 4、将solr解压目录`Solr-5.x.x/server/resources/log4j.properties`拷贝到Tomcat安装目录`/webapps/solr/WEB-INF/classes`中
* 5、配置Solr Home
	* 5.1、新建目录如:`/usr/local/solrhome`作为solr home目录, 拷贝solr解压目录`/solr-5.x.x/server/solr/solr.xml`拷贝到solr home目录中, 拷贝solr解压目录`/solr-5.x.x/server/solr/configsets/basic_configs`拷贝到solr home目录中并重命名为core, 它是一个实例
	* 5.2、solrhome目录下面可能会有多个solr实例, 每个solr实例文件夹下面的`conf/solrconfig.xml`, 可以配置相关的solr配置.
	* 5.3、如果solr管理页面`logging`报错: <font color=red>`Can't find: admin-xxx.html`</font>
		* 解决方法: 将`/solr-5.x.x/example/example-DIH/solr/solr/conf`目录下的`admin-extra.xml、admin-extra.menu-bottom.html和admin-extra.menu-top.html`拷贝到solr home目录下的`solr实例/conf`目录即可
* 6、修改tomcat安装目录下`/webapps/solr/WEB-INF/web.xml`
```xml
<env-entry>
    <env-entry-name>solr/home</env-entry-name>
    <env-entry-value>/usr/local/solrhome</env-entry-value>
    <env-entry-type>java.lang.String</env-entry-type>
</env-entry>
```

	* `env-entry-name`: 名字必须是`solr/home`, 不能更改
	* `env-entry-value`: 里面的值就是Solr Home路径
* 7、其他tomcat, 通过`tomcat地址:端口/solr/admin.html`访问
* 8、如果打开solr管理页面报错solr5.5部署报错:`java.lang.NoSuchMethodError:javax.servlet.ServletInputStream.isFinished()Z`, 请使用Tomcat8
* 9、多个solr实例请复制solr home目录中的solr文件夹并重命名为其他名称,并注意修改`core.properties`中的name字段为当前solr实例名称.

### <font color=orange> Solr后台管理页面 </font>
#### <font color=orange> 一级菜单 </font>
<center>
<img src="http://oak4eha4y.bkt.clouddn.com/solr-admin.png" alt="solr" style="width: 100%; text-align: center; display: block;"/>
</center>

* `Dashboard`: 仪表盘，显示了该Solr实例开始启动运行的时间、版本、系统资源、jvm等信息。
* `Logging`: Solr运行日志信息
* `Cloud`: Cloud即SolrCloud，即Solr云（集群），当使用Solr Cloud模式运行时会显示此菜单
* `Core Admin`: Solr Core的管理界面。Solr Core 是Solr的一个独立运行实例单位，它可以对外提供索引和搜索服务，一个Solr工程可以运行多个SolrCore（Solr实例），一个Core对应一个索引目录。
* `java properties`: Solr在JVM 运行环境中的属性信息，包括类路径、文件编码、jvm内存设置等信息。
* `Tread Dump`: 显示Solr Server中当前活跃线程信息，同时也可以跟踪线程运行栈信息。
* `Core selector`: 可以选择Solr实例
* `Collection Selector`: Solr云（集群)版才会显示

#### <font color=orange> 二级菜单 </font>
通过Core Selector选择一个Solr实例后, 会进入一个二级菜单.

<center>
<img src="http://oak4eha4y.bkt.clouddn.com/solr-two.png" alt="solr" style="width: 100%; text-align: center; display: block;"/>
</center>

* `Overview`:显示一些统计信息和元数据。
* `Analysis`:帮你设计你的Analyzer，Tokenizer和Filter。
* `Dataimport`: 展示当前的DataimportHandler的状态，默认是没有。
* `Documents`: 提供了一个让你对该solr实例中的数据作增删改操作的表单窗口。
* `Files`: 不是指存在solr实例中的业务数据，而是指该solr实例的配置文件，比如solrconfig.xml。
* `Query`: 一个简单的结构化查询工具。具体见(Solr页面查询各个参数解释)
* `Ping`: 按一下可以看这个solr实例还是不是活着的以及响应时间。
* `Plugins`: Solr自带的一些插件以及我们安装的插件的信息以及统计。
* `Replication`:显示你当前solr实例的副本，并提供disable/enable功能。
* `Schema`: 展示该Core的shema数据，如果是用ManagedSchema模式，还可以通过该页面修改，增加，删除schema的字段。(对比Solr4，是一个比较实用的提升。)
* `Segments info`:展示底层Lucence的分段信息。
