---
layout: post
title: Java语言基础02---进制、原反补码、基本数据类型、常量、变量、运算符
comments: true
date: 2016-05-04 16:06:35
tags:
	- Java
---

## <font color=orange>进制</font>
常用的进制有二进制、八进制和十六进制,对于任何一种进制,表示在某一位置的运算时逢x进一位.
<!--more-->
### 二进制
由0和1组成,在计算机中以8个二进制数作为最小单位:字节byte,在Java中SDK1.7之后可以用0B或者0b开头表示二进制数字

	1byte = 8bit
	1K = 1024byte
	1M = 1024K
	1G = 1024M
	1T = 1024G
### 八进制
八进制是将8位二进制数,每三位组成一个数字,不足最高位补0, Java中以0开头表示
### 十六进制
十六进制是将8位二进制数,每四位组成一个数字, Java中以0x或0X开头

### 进制转换
* 其他进制转十进制: 把系数*基数的权次幂相加即可
	* 系数:就是每位上面的数字
	* 基数:x进制,基数就是X
	* 权: 从右边0开始,对应位上的编号即为该位的权
* 十进制转其他进制: 使用除积倒取余数方法
	* 转换成二进制:一直除以2,然后倒取余数
	* 转换成八进制:可以先转换成二进制后,再从右边每三位转为一位数字,不足位数最高位补0,也可以直接使用除积倒取余数方法
	* 转换成十六进制:可以先转换成二进制后,再从右边每四位转为一位数字,不足位数最高位补0,也可以直接使用除积倒取余数方法

## 计算机中计算都是以补码形式来运算的

### 原码
* 就是二进制定点表示法,最高位为符号位,0表示正, 1表示负
### 反码
* 正数的反码和其原码相同;负数的反码是对其原码逐位取反,但是符号位不变
### 补码
* 正数的补码和其原码相同;负数的补码是在其反码的末位加1


## <font color=orange>常量</font>
- 常量: 在程序执行过程中其值不可以发生改变

- Java中的常量分类
	- 字面量常量
		- 字符串常量(用双引号括起来的内容)如: "abc"、"我们都是好孩子"
			- OC中需要在前面添加@符号
			- Swift表示方法和Java一致
		- 整数常量(所有整数)如: 123、345
		- 小数常量(所有小数)如: 1.90、90.1
		- 字符常量(用单引号括起来的内容,只能是单个数字、字母或者符号, 可以放一个空格,但是不能什么都不放)如: ' '、'1'、'a', '10'、''和'ab'都是错误的
		- 布尔常量(true和false)
			- OC中可以是0和非0, YES和NO
			- Swift中也是true和false
		- 空常量(null)
	- 自定义常量

## <font color=orange>变量</font>
- 变量: 在程序执行的过程中,在某个范围其值可以发生改变的量
- 变量格式: 数据类型 变量名 = 变量值
	- OC格式是 数据类型 (\*)变量名 = 变量值, 不是基本类型需要添加\*,表示指针
	- Swift中使用var声明的是变量,let声明的是常量
- Java语言是强类型语言,对于每一种数据都定义了明确的具体数据类型,在内存中分配了不同大小的内存空间.
	- OC是运行时语言,运行时才会确定对象的类型
	- Swift是强类型语言, 声明的时候可以不指定类型,系统会类型推导
## <font color=orange>Java中数据类型分类</font>
- 基本数据类型
	- 整数型
		- byte 占一个字节(8bit)-128 ~ 127
		- short 占两个字节 -2^15 ~ 2^15-1
		- int 占四个字节 -2^31 ~ 2^31-1
		- long 占八个字节 -2^63 ~ 2^63-1
	- 浮点型
		- float单精度 占四个字节 -3.403E38 ~ 3.404E38
		- double双精度 占八个字节 -1.798E308 ~ 1.798E308
	- 字符型
		- char 占两个字节 0 ~ 65535, 可以存放汉字
	- 布尔型
		- boolean 只有true和false, Java中没有明确指定它的大小
- 引用数据类型
	- 数组
	- 类
	- 接口
	- 枚举

__Java中整数默认类型是int, 如果赋值给long类型的大数最好后面添加L(或小写l), 浮点数默认是double类型,如果浮点数要赋值给float,需要在后面添加F(或小写f).如:float f = 12.3f; long x = 8888888888L;__

## 使用变量的主要事项
* 作用域问题,同一个作用域不能使用相同的变量名
* 初始化问题,局部变量在使用前必须赋值
* 一条语句可以定义几个相同类型变量 int a,b,c...;

### 类型转换
低位转高位可以隐式转换, 高位转低位需要强制转换(会把多余的高位去掉),但是结果可能不对
	- Swift类型都需要转换, 不同类型不能进行加减乘除等操作
	//数据类型转换 
	//隐式转换
	int x = 12312123;
	byte b = 4;
	x = x + b; // 隐式转换
	//强制转换
	b = (byte)(x + b);
	byte c = (byte)(126 + 4); //结果-126

关于数据类型转换的面试题:

	byte b1 = 3;
	byte b2 = 4;
	byte b3 = b1 + b2;
	/*
	1. byte与byte(short、char)进行混合运算, 会提升至int类型
	2. b1和b2是变量,编译的时候无法判断会不会超过byte的值
	*/
	byte b4 = 3 + 4; //OK Java对常量有优化机制,会在编译的时候计算出3 + 4的值赋值给b4, 如果超过byte范围则会报错~
	

### float和long的大小
* float占4个字节, 第一位代表符号位,8位表示指数位, 23位代表尾数位, IEEE 754标准规定,0表示0, 255表示无穷大,指数位是00000000 ~~ 11111111 范围是1 ~~ 254, 指数位范围是2的 -126 ~~ 127次幂
* long: 2^63 - 1
* float:3.4*10^38>3.4*8^38>2*2^*2^3*38>2^63-1

## 字符和字符串参与的运算

	System.out.println('a');  //a
	System.out.println('a' + 1); //98

* 任意数据类型使用+和字符串相连都会生成新的字符串
>System.out.println("hello" + 'a' + 1); /helloa1
System.out.println('a' + 1 + "hello"); //98hello
`System.out.println("5 + 5 =" + (5 + 5)); //5 + 5 = 10

* ASCII码表
![ASCII](http://47.96.147.179/images/java/ASCII.jpg)

## <font color=orange>运算符</font>
* 运算符分类
	* 算术运算符
		* +、-、*、/、++(自增)、--(自减)、%(取余)
>int a = 4, b = 4;
int c = a++;  //c = 4, a = 5
int d = ++b;  //d = 5, b = 5
int a1 = 4;
int a2 = (a1++) + (++a1) + (a1 * 10); //4 + 6 + 60
</br>
>byte b1 = 7;
b1++; //系统底层做了强制类型转换 b1 = (type)(b1 + 1)
b1 = b1 + 1; //报错因为byte和int类型运算会提升到int类型,再赋值给type会损失精度

		* +在Java中有三种作用
			* 算术运算符
			* 代表正号
			* 字符串连接符
		* 整数相除只能得到整数,如果要得到小数,只需把一个数转为浮点数类型
		* /获取的商值,而%获取的除法操作的余数
		* %运算符的结果只与左边有关系,和右边没有关系
		* 任何一个正整数%2的结果不是0就是1
		* ++和--单独使用的时候,效果都是一样的,但是参与运算的时候,放在前面先自增或自减后参与运算, 放在后面先参与运算后自增或自减
			* OC中++和--作用一样
			* Swift新版本中已经移除++和--运算符
	* 赋值运算符
		* =、+=、-=、*=、/=、%=
		* a += b 等价于 a = a + b
	* 关系运算符
		* ==、!=、>、>=、<、<=
		* 关系运算符==不要漏写成=
	* 逻辑运算符
		* &(逻辑与:全为true才为true)、|(逻辑或:全为false才为false)、^(逻辑异或:相同为false,不同为true)、!(逻辑非:取反)
		* && 和 & 效果一样,但是&&具有短路作用,当&&前面为false,后面不会执行.&都会执行
		* ||和|效果一样, 但是||具有短路作用,当||前面结果为true,后面不会执行.|都会执行
	* 位运算符
		* & 按位与,有0则是0
		* | 按位或,有1则是1
		* ^ 按位异或,相同则是0,不同为1
			* ^的特点一个数对另外一个数异或两次,该数不会变化
			* 不使用第三方变量实现两个数的交换
> int a = 10, b = 5;//只能是整数型
a = a ^ b;
b = a ^ b;
a = a ^ b;
>//还可以使用\*来做 可能会超过范围,浮点型数据可能有精度问题
a = a * b;
b = a / b;
b = a / b;
>//使用\+来做,可能会超过范围,浮点型数据可能有精度问题
a = a + b;
b = a - b;
a = a - b;
		* \~ 按位取反~11100 ---->00011
		* <<左移:左边最高位丢弃,右边补0
		* \>\>右移:最高位是0,左边补0, 最高位是1,左边补1
		* \>\>\>无符号右移, 无论最高位是什么,左边补0
		* 最有效率算出2 * 8的结果
>System.out.println(2 << 3);
	* 三目运算符(三目运算符)
		* (关系表达式) ? 表达式1 : 表达式2
> int a = 10;
int b = (a == 10) ? 100 : 200;

### 注意事项
* type、short、char和int之间的运算先提升到int类型, 如果结果赋值给type、short和char类型会损失精度,需要注意



