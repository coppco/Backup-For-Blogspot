---
layout: post
title: Java语言基础02---进制、原反补码、基本数据类型、常量、变量、运算符
comments: true
date: 2016-05-04 16:06:35
tags:
	- Java
---

## 进制

常用的进制有二进制、八进制和十六进制,对于任何一种进制,表示在某一位置的运算时逢x进一位.
<!--more-->
### 二进制
我们知道计算机是可以用来存储数据的，但是无论是内存还是硬盘，计算机存储设备的最小信息单元叫“位（bit）”，我们又称之为“比特位”，通常用小写的字母”b”表示。而计算机中最基本的存储单元叫“字节（byte）”，

由0和1组成,在计算机中以8个二进制数作为最小单位:字节byte,在Java中SDK1.7之后可以用0B或者0b开头表示二进制数字

	1byte = 8bit
	1K = 1024byte
	1M = 1024K
	1G = 1024M
	1T = 1024G
### 八进制
八进制是将8位二进制数,每三位组成一个数字,不足最高位补0, Java中以0开头表示
### 十六进制
十六进制是将8位二进制数,每四位组成一个数字, Java中以0x或0X开头

### 进制转换
* 其他进制转十进制: 把系数*基数的权次幂相加即可
	* 系数:就是每位上面的数字
	* 基数:x进制,基数就是X
	* 权: 从右边0开始,对应位上的编号即为该位的权
* 十进制转其他进制: 使用除积倒取余数方法
	* 转换成二进制:一直除以2,然后倒取余数
	* 转换成八进制:可以先转换成二进制后,再从右边每三位转为一位数字,不足位数最高位补0,也可以直接使用除积倒取余数方法
	* 转换成十六进制:可以先转换成二进制后,再从右边每四位转为一位数字,不足位数最高位补0,也可以直接使用除积倒取余数方法

__计算机中计算都是以补码形式来运算的__

### 原码
* 就是二进制定点表示法,最高位为符号位,0表示正, 1表示负
### 反码
* 正数的反码和其原码相同;负数的反码是对其原码逐位取反,但是符号位不变
### 补码
* 正数的补码和其原码相同;负数的补码是在其反码的末位加1

## Java中数据类型

|   数据类型   |          |    关键字    | 内存占用 |                           取值范围                           |
| :----------: | :------: | :----------: | :------: | :----------------------------------------------------------: |
| 基本数据类型 | 整数类型 |     byte     |    1     |                           -128~127                           |
|              |          |    short     |    2     |                         -32768~32767                         |
|              |          |  int(默认)   |    4     |                   -2的31次方到2的31次方-1                    |
|              |          |     long     |    8     |                   -2的63次方到2的63次方-1                    |
|              | 浮点类型 |    float     |    4     | 负数：-3.402823E+38到-1.401298E-45   正数：   1.401298E-45到3.402823E+38 |
|              |          | double(默认) |    8     | 负数：-1.797693E+308到-4.9000000E-324    正数：4.9000000E-324   到1.797693E+308 |
|              | 字符类型 |     char     |    2     |                           0-65535                            |
|              | 布尔类型 |   boolean    |    1     |                         true，false                          |
| 引用数据类型 |   数组   |      []      |    -     |                              -                               |
|              |    类    |    class     |    -     |                              -                               |
|              |   接口   |  interface   |    -     |                              -                               |

__Java中整数默认类型是int, 如果赋值给long类型的大数最好后面添加L(或小写l), 浮点数默认是double类型,如果浮点数要赋值给float,需要在后面添加F(或小写f).如:float f = 12.3f; long x = 8888888888L;__

## 常量

- 常量: 在程序执行过程中其值不可以发生改变

- Java中的常量分类
  - 字面量常量
    - 字符串常量(用双引号括起来的内容)如: "abc"、"我们都是好孩子"
    - 整数常量(所有整数)如: 123、345
    - 小数常量(所有小数)如: 1.90、90.1
    - 字符常量(用单引号括起来的内容,只能是单个数字、字母或者符号, 可以放一个空格,但是不能什么都不放)如: ' '、'1'、'a', '10'、''和'ab'都是错误的
    - 布尔常量(true和false)
    - 空常量(null)
  - 自定义常量

## 变量

- 变量: 在程序执行的过程中,在某个范围其值可以发生改变的量
- 变量格式: 数据类型 变量名 = 变量值
- Java语言是强类型语言,对于每一种数据都定义了明确的具体数据类型,在内存中分配了不同大小的内存空间.
## 使用变量的主要事项
* 同一个作用域不能使用相同的变量名。
* 变量在使用之前，必须初始化（赋值）。
* 定义long类型的变量时，需要在整数的后面加L（大小写均可，建议大写）。因为整数默认是int类型，整数太大可能超出int范围。
* 定义float类型的变量时，需要在小数的后面加F（大小写均可，建议大写）。因为浮点数的默认类型是double， double的取值范围是大于float的范围。
* 一条语句可以定义几个相同类型变量 int a,b,c...;

## 类型转换

在Java中，一些数据类型之间是可以相互转换的。分为两种情况：自动类型转换和强制类型转换。

自动类型转换：

​	把一个表示数据范围小的数值或者变量赋值给另一个表示数据范围大的变量。这种转换方式是自动的，直接书写即可。例如：

```java
double num = 10; // 将int类型的10直接赋值给double类型
System.out.println(num); // 输出10.0
```

强制类型转换：

​	把一个表示数据范围大的数值或者变量赋值给另一个表示数据范围小的变量。

​	强制类型转换格式：目标数据类型 变量名 = (目标数据类型)值或者变量;

​	例如：

```
double num1 = 5.5;
int num2 = (int) num1; // 将double类型的num1强制转换为int类型
System.out.println(num2); // 输出5（小数位直接舍弃）
```

说明：

1. char类型的数据转换为int类型是按照码表中对应的int值进行计算的。比如在ASCII码表中，'a'对应97。

```java
int a = 'a';
System.out.println(a); // 将输出97
```

2. 整数默认是int类型，byte、short和char类型数据参与运算均会自动转换为int类型。
3. boolean类型不能与其他基本数据类型相互转换。

关于数据类型转换的面试题:

	byte b1 = 3;
	byte b2 = 4;
	byte b3 = b1 + b2;
	/*
	1. byte与byte(short、char)进行混合运算, 会提升至int类型
	2. b1和b2是变量,编译的时候无法判断会不会超过byte的值
	*/
	byte b4 = 3 + 4; //OK Java对常量有优化机制,会在编译的时候计算出3 + 4的值赋值给b4, 如果超过byte范围则会报错~

## float和long的大小

* float占4个字节, 第一位代表符号位,8位表示指数位, 23位代表尾数位, IEEE 754标准规定,0表示0, 255表示无穷大,指数位是00000000 ~~ 11111111 范围是1 ~~ 254, 指数位范围是2的 -126 ~~ 127次幂
* long: 2^63 - 1
* float:3.4*10^38>3.4*8^38>2*2^*2^3*38>2^63-1

## 字符和字符串参与的运算

	System.out.println('a');  //a
	System.out.println('a' + 1); //98

* 任意数据类型使用+和字符串相连都会生成新的字符串
>System.out.println("hello" + 'a' + 1); /helloa1
System.out.println('a' + 1 + "hello"); //98hello
`System.out.println("5 + 5 =" + (5 + 5)); //5 + 5 = 10

* ASCII码表
  ![ASCII](http://47.96.147.179/images/java/ASCII.jpg)

## 运算符

* 运算符分类

  * 算术运算符： `+`、`-`、`*`、`/(整数之间只能得到整数)`、`++`(自增)、`--`(自减)、`%`(取余)

    ```
    int a = 4, b = 4;
    int c = a++;  //c = 4, a = 5
    int d = ++b;  //d = 5, b = 5
    int a1 = 4;
    int a2 = (a1++) + (++a1) + (a1 * 10); //4 + 6 + 60
    
    byte b1 = 7;
    b1++; //系统底层做了强制类型转换 b1 = (type)(b1 + 1)
    b1 = b1 + 1; //报错因为byte和int类型运算会提升到int类型,再赋值给type会损失精度
    ```

    * `+`在Java中有三种作用
      * 算术运算符
      * 代表正号
      * 字符串连接符
    * 整数相除只能得到整数,如果要得到小数,需要有浮点数参与运算
    * `/`获取的商值,而%获取的除法操作的余数
    * `%`运算符的正负结果只与左边有关系,和右边没有关系
    * 任何一个正整数%2的结果不是0就是1
    * `++`和`--`单独使用的时候,效果都是一样的,但是参与运算的时候,放在前面先自增或自减后参与运算, 放在后面先参与运算后自增或自减

  * 赋值运算符: `=`、`+=`、`-=`、`*=`、`/=`、`%=`

    * `a += b`等价于 `a = a + b`, 但是编译器做了强制类型转换，和`++`一样

  * 关系运算符：`==`、`!=`、`>`、`>=`、`<`、`<=`

  * 三目运算符： `(关系表达式) ? 表达式1 : 表达式2`

  * 逻辑运算符

    * `&`: 逻辑与
    * `|`: 逻辑或
    * `^`: 逻辑异或
    * `!`: 逻辑非

  * 短路逻辑运算符

    * `&&`: 作用和&相同，但是有短路效果
    * `||`: 作用和\|相同，但是有短路效果

  * 位运算符

    * `& `按位与,有0则是0

    * `|` 按位或,有1则是1

    * `^` 按位异或,相同则是0,不同为1

      * ^的特点: 一个数对另外一个数异或两次,该数不会变化, 所以可以不使用变量实现交互两个整数

        ```
        int a = 10, b = 5;//只能是整数型
        a = a ^ b;
        b = a ^ b;
        a = a ^ b;
        //还可以使用\*来做 可能会超过范围,浮点型数据可能有精度问题
        a = a * b;
        b = a / b;
        b = a / b;
        //使用\+来做,可能会超过范围,浮点型数据可能有精度问题
        a = a + b;
        b = a - b;
        a = a - b;
        ```

    * `~`: 按位取反

      * `~11100`      `00011`

    * `<<`: 左移

      * 左边最高位丢弃,右边补0
      * 可以快速得到

    * `>>`: 右移

      * 最高位是0,左边补0, 最高位是1,左边补1

    * `>>>`: 无符号右移

      *  无论最高位是什么,左边补0

### 注意事项
* type、short、char和int之间的运算先提升到int类型, 如果结果赋值给type、short和char类型会损失精度,需要注意



